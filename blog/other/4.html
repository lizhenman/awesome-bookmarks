<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>前言 | awesome-bookmarks</title>
    <meta name="description" content="个人收藏际夹 beta">
    <link rel="icon" href="/awesome-bookmarks/favicon.ico">
    
    <link rel="preload" href="/awesome-bookmarks/assets/css/0.styles.17e9ebf2.css" as="style"><link rel="preload" href="/awesome-bookmarks/assets/js/app.36e9bca3.js" as="script"><link rel="preload" href="/awesome-bookmarks/assets/js/38.ba319fea.js" as="script"><link rel="prefetch" href="/awesome-bookmarks/assets/js/10.f2324d34.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/11.404b0ff7.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/12.b24d262f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/13.617c869e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/14.051f1a89.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/15.346b4e85.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/16.f34a9b90.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/17.c1f8c880.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/18.0524509b.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/19.967a9a5e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/2.d8f505d4.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/20.7081d57c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/21.5afa7b76.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/22.169efb6a.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/23.eaf48cd1.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/24.df3f0074.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/25.c21109bf.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/26.8e233142.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/27.c96d3f82.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/28.fb9b178e.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/29.b0e4576c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/3.0e436cc3.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/30.5c60f21d.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/31.4b578045.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/32.16f4713f.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/33.f58dd516.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/34.83358bd6.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/35.a594987c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/36.dc267ffa.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/37.f6710068.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/39.9f32f599.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/4.42f5ced8.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/40.8cbbe22c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/41.79669c44.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/42.6b472d26.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/43.84e89645.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/44.56a90f09.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/45.d44311a1.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/46.113695b7.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/47.e6229915.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/48.b6b909a0.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/49.1aea0402.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/5.22d62c09.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/50.11a12af9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/51.3950c0a9.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/52.4e6da3fc.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/53.5e894fef.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/54.01b534c4.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/55.ded4f4d5.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/56.da1b6352.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/6.7619ba2c.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/7.79724095.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/8.c287a922.js"><link rel="prefetch" href="/awesome-bookmarks/assets/js/9.3c38378c.js">
    <link rel="stylesheet" href="/awesome-bookmarks/assets/css/0.styles.17e9ebf2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/awesome-bookmarks/" class="home-link router-link-active"><!----> <span class="site-name">awesome-bookmarks</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/awesome-bookmarks/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/awesome-bookmarks/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/awesome-bookmarks/blog/" class="nav-link router-link-active">Blog</a></div> <a href="https://github.com/PanJiaChen/awesome-bookmarks" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/awesome-bookmarks/" class="nav-link">首页</a></div><div class="nav-item"><a href="/awesome-bookmarks/repository/" class="nav-link">库</a></div><div class="nav-item"><a href="/awesome-bookmarks/website/" class="nav-link">网站</a></div><div class="nav-item"><a href="/awesome-bookmarks/article/" class="nav-link">文章</a></div><div class="nav-item"><a href="/awesome-bookmarks/interview/" class="nav-link">面试</a></div><div class="nav-item"><a href="/awesome-bookmarks/blog/" class="nav-link router-link-active">Blog</a></div> <a href="https://github.com/PanJiaChen/awesome-bookmarks" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>Blog</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/awesome-bookmarks/blog/" class="sidebar-link">前言</a></li><li><a href="/awesome-bookmarks/blog/cs.html" class="sidebar-link">CS</a></li><li><a href="/awesome-bookmarks/blog/es6.html" class="sidebar-link">ES6</a></li><li><a href="/awesome-bookmarks/blog/fe.html" class="sidebar-link">前端</a></li><li><a href="/awesome-bookmarks/blog/google-developer.html" class="sidebar-link">读谷歌开发指南</a></li><li><a href="/awesome-bookmarks/blog/js.html" class="sidebar-link">Javascript</a></li><li><a href="/awesome-bookmarks/blog/other.html" class="sidebar-link">Other</a></li><li><a href="/awesome-bookmarks/blog/performance .html" class="sidebar-link">前端性能监控</a></li><li><a href="/awesome-bookmarks/blog/product.html" class="sidebar-link">产品</a></li><li><a href="/awesome-bookmarks/blog/talk.html" class="sidebar-link">Talk</a></li><li><a href="/awesome-bookmarks/blog/vue.html" class="sidebar-link">Vue</a></li><li><a href="/awesome-bookmarks/blog/webpack.html" class="sidebar-link">Webpack</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h2 id="前言"><a href="#前言" aria-hidden="true" class="header-anchor">#</a> 前言</h2> <p>从 <code>17 Apr 2017</code>提交第一个 commit 至今已经有两年的事件了，发布了四十多个版本，有七十多个 contributors 协助。离上次手摸手系列也过去了很久，当时写的有些内容，随着技术的不断迭代，很多之前的问题都已经解决了，同时也面临着一些新的挑战。</p> <p>所以本文前半部分，主要说一下 4.0 版本做了什么事情，后半部分文章则会分享一些新的思考和小技巧吧。</p> <p>本篇文章</p> <h2 id="_4-0-做了什么"><a href="#_4-0-做了什么" aria-hidden="true" class="header-anchor">#</a> 4.0 做了什么</h2> <h2 id="vue-cli-3"><a href="#vue-cli-3" aria-hidden="true" class="header-anchor">#</a> vue-cli@3</h2> <h2 id="本地预览"><a href="#本地预览" aria-hidden="true" class="header-anchor">#</a> 本地预览</h2> <p>dist 目录需要启动一个 HTTP 服务器来访问 (除非你已经将 publicPath 配置为了一个相对的值)，所以以 file:// 协议直接打开 dist/index.html 是不会工作的。在本地预览生产环境构建最简单的方式就是使用一个 Node.js 静态文件服务器，例如 <a href="https://github.com/zeit/serve" target="_blank" rel="noopener noreferrer">serve<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> <span class="token function">install</span> -g serve
<span class="token comment"># -s 参数的意思是将其架设在 Single-Page Application 模式下</span>
<span class="token comment"># 这个模式会处理即将提到的路由问题</span>
serve -s dist
</code></pre></div><p>preview</p> <p>https://segmentfault.com/a/1190000016314976</p> <h2 id="redirect"><a href="#redirect" aria-hidden="true" class="header-anchor">#</a> redirect</h2> <h2 id="addrouters"><a href="#addrouters" aria-hidden="true" class="header-anchor">#</a> addRouters</h2> <h2 id="mock-数据"><a href="#mock-数据" aria-hidden="true" class="header-anchor">#</a> Mock 数据</h2> <p>如果你在实际开发中，最理想的前后端交互方式当然是后端先帮我们 mock 数据，但现实很骨感，总是因为种种原因，前端需要自己来 mock 假数据。尤其是我的几个开源项目，都是纯前端项目，根本没有后端服务。
在之前的文章中也介绍过，<code>vue-element-admin</code> 和 <code>vue-admin-template</code> 使用的是 <a href="https://github.com/nuysoft/Mock" target="_blank" rel="noopener noreferrer">MockJS<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 和<a href="https://github.com/easy-mock/easy-mock" target="_blank" rel="noopener noreferrer">easy-mock<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这两个库。但实际用下来两者都有很大的问题。</p> <ul><li><p>MockJs</p> <p>它的最大的问题是就是它的实现原理，它会重写 <code>XMLHttpRequest</code>对象，从而实现本地拦截所有请求，代理到本地实现 mock 功能。大部分情况下用起来还是蛮爽的，但因为它重写了<code>XMLHttpRequest</code>对象，所以比如<code>progress</code>方法，或者一些底层依赖<code>XMLHttpRequest</code>的库都会和它发生不兼容，可以看一下我项目的<a href="https://github.com/PanJiaChen/vue-element-admin/issues?utf8=%E2%9C%93&q=mock" target="_blank" rel="noopener noreferrer">issues<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，就知道多少人被坑了。</p> <p>它还有一个问题是，因为是它本地模拟的数据，实际上不会走任何网络请求。所以调试起来很蛋疼，只能通过<code>console.log</code>来调试，就拿<code>vue-element-admin</code>来说，想搞清楚 <code>getInfo()</code>接口返回了什么数据，只能通过看源码或者手动 debug 才能知道。</p></li> <li><p>Easy-Mock</p> <p>这个项目刚出的时候用的人比较少，还真的挺好用的。天然支持跨域，还是支持<code>MockJs</code>的所以语法，我在之前也推荐过。不过最近一年多，它的免费服务经常的挂，可以说天天挂。。。但毕竟人家这是免费的服务，也不能苛求什么，官方的建议是自己搭建服务。如果你的公司整体搭建一个这样的 mock 服务的话也是一个不错的选择。但大部分人可能还是没有这个技术条件的。</p></li></ul> <h3 id="新方案"><a href="#新方案" aria-hidden="true" class="header-anchor">#</a> 新方案</h3> <p>所以我一直在寻求一个更好的解决方案，我也去体验了其它很多 mock api 服务，如<a href="https://www.mockapi.io/login" target="_blank" rel="noopener noreferrer">mockapi<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://www.mocky.io/" target="_blank" rel="noopener noreferrer">Mocky<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>等等总之体验都不能满足我的需求。</p> <p>后来有位网友提交了一个<a href="https://github.com/PanJiaChen/vue-element-admin/pull/1267" target="_blank" rel="noopener noreferrer">pr<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我看了下觉得这是一个可行的方案。我在它的基础上稍微改造了下，让它能更好的适配 restful api。</p> <p>先简单说一下原理：</p> <p>在本地开发环境中基于 <code>webpack-dev-serve</code>的 <code>after</code>这个<code>middleware中间件</code>，在这里自动读取你的 <code>mock</code>文件，模拟出 REST API，它最大的好处是，完全不需要什么额外的工作，基于<code>webpack-dev-serve</code>就能实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">after</span><span class="token punctuation">(</span><span class="token parameter">app</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'@babel/register'</span><span class="token punctuation">)</span>
      <span class="token keyword">const</span> bodyParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'body-parser'</span><span class="token punctuation">)</span>

      <span class="token comment">// parse app.body</span>
      <span class="token comment">// http://expressjs.com/en/4x/api.html#req.body</span>
      app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>bodyParser<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>bodyParser<span class="token punctuation">.</span><span class="token function">urlencoded</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
        extended<span class="token punctuation">:</span> <span class="token boolean">true</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

      <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">default</span><span class="token punctuation">:</span> mocks <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./mock'</span><span class="token punctuation">)</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> mock <span class="token keyword">of</span> mocks<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        app<span class="token punctuation">[</span>mock<span class="token punctuation">.</span>type<span class="token punctuation">]</span><span class="token punctuation">(</span>mock<span class="token punctuation">.</span>url<span class="token punctuation">,</span> mock<span class="token punctuation">.</span>response<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
</code></pre></div><p>我们模拟数据有了，现在要做的事情就是，将我们的接口代理到我们的 mock 服务上就好了，这里我们可以使用 <code>proxy</code>，</p> <div class="language-js extra-class"><pre class="language-js"><code>proxy<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// xxx-api/login =&gt; mock/login</span>
      <span class="token punctuation">[</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">VUE_APP_BASE_API</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>
        target<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`http://localhost:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>port<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">/mock`</span></span><span class="token punctuation">,</span>
        changeOrigin<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        pathRewrite<span class="token punctuation">:</span> <span class="token punctuation">{</span>
          <span class="token punctuation">[</span><span class="token string">'^'</span> <span class="token operator">+</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">VUE_APP_BASE_API</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token string">''</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><h3 id="snippets"><a href="#snippets" aria-hidden="true" class="header-anchor">#</a> snippets</h3> <p>平时日常工作中，做最多的就是写业务模块和组件。当每次新开一个<code>view</code>或者<code>component</code>的时候都需要手动创建一个新<code>.vue</code>，然后创建一个<code>&lt;template&gt;</code>、<code>&lt;script&gt;</code>、<code>&lt;style&gt;</code>，还是有些麻烦的。</p> <p>所以在新版本中，基于<a href="https://github.com/amwmedia/plop" target="_blank" rel="noopener noreferrer">plop<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，提供了几个基础模板，方便创建新的<code>view</code>或者<code>component</code>。
执行如下命令：</p> <div class="language-bash extra-class"><pre class="language-bash"><code><span class="token function">npm</span> run new
</code></pre></div><p><img src="https://wpimg.wallstcn.com/5f8ea239-aaa5-4e91-9d09-ed56b33a110d.gif" alt="plop"></p> <p>如上面 gif 所示，现在只要轻松的点几次回车就可以轻松生成我要的基础代码判断。这里只是一个 demo，你可以按照自己需求定制模板， 老版本的<code>vue-cli</code>实现逻辑和它类似。</p> <p>如果你觉得配置太复杂，也可以安装如<a href="https://marketplace.visualstudio.com/items?itemName=hollowtree.vue-snippets" target="_blank" rel="noopener noreferrer">Vue 2 Snippets<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a><code>VS Code</code>插件。 这种定义好的代码判断。</p> <h3 id="async-await-or-promise"><a href="#async-await-or-promise" aria-hidden="true" class="header-anchor">#</a> async/await or promise</h3> <p>本次更新中，我将部分代码用了<code>async/await</code>的方式替代了原有的 <code>promise</code>方式，主要是<code>@/src/permission.js</code>。有兴趣的大家自己可以通过 <a href="https://github.githistory.xyz/PanJiaChen/vue-element-admin/blob/master/src/permission.js" target="_blank" rel="noopener noreferrer">git-history<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>自己对不一下。 不过本项目中也并没有把所有<code>promise</code>用<code>async/await</code>替代。我来简单说一下我的看法。</p> <p><a href="https://zhuanlan.zhihu.com/p/26260061" target="_blank" rel="noopener noreferrer">6 个 Async/Await 优于 Promise 的方面<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，这篇文章很多人应该都看过，里面大部分观点我都是同意的的，大部分复制场景下<code>async/await</code>是更优解。但相对的也不是所有的情况下都是``async/await<code>写起来让我更爽的。 先说说我最不爽的地方是它的错误处理，</code>try catch`让这个代码结构看起来就很奇怪（当然也有很多人很喜欢这种错误处理形式。社区也是相对的解决方案，比如<a href="https://github.com/scopsy/await-to-js" target="_blank" rel="noopener noreferrer">await-to-js<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">;</span><span class="token punctuation">[</span>err<span class="token punctuation">,</span> res<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">to</span><span class="token punctuation">(</span><span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">//dosomething</span>
</code></pre></div><p>这个方案是不错，但还需要引入一个新的库，增加了学习成本，得不偿失。所以以我个人的习惯，当只有一个异步请求，且需要做错误处理的情况下，更倾向于使用 <code>promise</code>。比如</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// promise</span>
<span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">res</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//do somethings</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token comment">//do somethings</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// async/await</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">//do somethings</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">//do somethings</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在有嵌套请求的情况下，肯定是 async/await 更直观的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// promise</span>
<span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// async/await</span>
<span class="token keyword">await</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">await</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">await</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>当然代码写的好与不好还是取决于写代码的人的。经常遇到一个业务场景：有两个并行的异步请求，在都完成后<code>do something</code>。但很多人会错误的用串行的方式实现了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//错误</span>
<span class="token keyword">await</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">await</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//这样变成了 a().then(() =&gt; b() )</span>
<span class="token comment">// a 好了才会执行 b</span>
<span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">//正确</span>
<span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>大小问题 <a href="https://babeljs.io/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYewdgzgLgBFCm0C8BDCBPMwYDMCuWUAluABQCUA3gFAwwCQokIANvAHQsgDmpKA7iiKxu8KAEkwOEBXLUAvtWpNoMURKkgk-QiTAUadAE5i8RsDDDx-MAApGQAWyIR4pUiYisAbvHJIAPkM6GE8fNwByEABrCLk6eTlFBGgKIA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=false&sourceType=module&lineWrap=true&presets=env&prettier=true&targets=&version=7.4.2" target="_blank" rel="noopener noreferrer">async/await<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <a href="https://babeljs.io/repl#?babili=false&browsers=&build=&builtIns=false&spec=false&loose=false&code_lz=MYewdgzgLgBFCm0C8AzArmYUCW4AUAlAN4BQMMAkAObxQCSYKIhAdFABbxh54BOiBJAD5S5MTFCQQAG3gtpIKnwFkxAXwIk1JEpOgwa9RiFQYsubsVX8oaXmBhh4AdxgAFXiAC22CPB78EDIAbvCCIqrkgSH-AOQgANaxmuQaWiQI0IRAA&debug=false&forceAllTransforms=false&shippedProposals=false&circleciRepo=&evaluate=true&fileSize=true&timeTravel=false&sourceType=module&lineWrap=true&presets=env&prettier=true&targets=&version=7.4.2" target="_blank" rel="noopener noreferrer">promise<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>当然这个是一个可以忽略不计得问题。</p> <p>总结，它们两个人并不是<code>or</code>的关系，在特定的业务场景下，选择相对而言代码可读性更好地解决方案。</p> <p>以上所述纯个人偏爱，并非什么最佳实现。具体该怎么选择还是需要大家更具自己团队的风格或者自己的理解来判断。比如现在我 code review 的时候 是用 promise 还是 <code>async/await</code>，我都会点通过的。</p> <p>// set function parseTime, formatTime to filter</p> <h2 id="小技巧"><a href="#小技巧" aria-hidden="true" class="header-anchor">#</a> 小技巧</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// don't</span>
<span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchUserList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  searchText<span class="token punctuation">:</span> <span class="token string">'fetchUserList'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>

<span class="token comment">// do</span>
watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  searchText<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    handler<span class="token punctuation">:</span> <span class="token string">'fetchUserList'</span><span class="token punctuation">,</span>
    immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>v-bind=&quot;$props&quot; v-on=&quot;$listeners
.sync
get set
Object.freeze(users)</p> <h2 id="hook"><a href="#hook" aria-hidden="true" class="header-anchor">#</a> hook</h2> <p>这个是一个文档里没有写的 api，但我觉得是一个很有用的 api。比如我们平时使用一些第三方组件，或者注册一些全局事件的时候，都需要在<code>mounted</code>中声明，在<code>destroyed</code>中销毁，但由于这个是写在两个生命周期内的，很容易忘记，而且大部分在创建阶段声明的内容都会有副作用，如果你在组件摧毁阶段忘记移除的话，会造成内存的泄漏，而且都不太容易发现。如下代码：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be2ce408a53bd?w=1072&h=370&f=png&s=62669" alt>。</p> <p>react 在新版本中也加入了<code>useEffect</code>，将以前的多个 life-cycles 合并、重组，使逻辑更加清晰，这里就不展开了。那 vue 是不是也可以这样做？我去了看了一下官方的 <code>vue-hooks</code>的<a href="https://github.com/yyx990803/vue-hooks/blob/master/index.js" target="_blank" rel="noopener noreferrer">源码<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>发现了一个新的 api<code>$on('hook:xxx')</code>，有了它，我们就能之前的代码用更简单和清楚地方式实现了。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be2ce41fcc232?w=1104&h=406&f=png&s=67807" alt></p> <p>而且我们有了这个 api 之后，能干的事情还不止这个。有时候我们会用一些第三方组件，比如我们有一个编辑器组件（加载比较慢，会有白屏），所以我们在它渲染完成之前需要给它一个占位符，但这时候这个组件可能就没有暴露给我们这个接口，或者我们需要修改这个组件，在它创建的时候手动 emit 一个事件出去，然后在组件上监听它，比如：</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be2ce45eabd8a?w=616&h=334&f=png&s=38001" alt></p> <p>当然这也是可行的，但万一还要监听一个更新或者摧毁的生命周期呢？其实利用 <code>hook</code>可以很方便的实现这个效果。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be30ee530a45b?w=682&h=150&f=png&s=14691" alt></p> <p>当然在 vue 3.0 版本中可能会有新的写法，就不如下面的讨论: <a href="https://github.com/vuejs/rfcs/pull/23" target="_blank" rel="noopener noreferrer">Dynamic Lifecycle Injection<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。有兴趣的可以自行去研究，这里就不展开了。当 3.0 正式发布之后再来讨论吧。</p> <h3 id="functional"><a href="#functional" aria-hidden="true" class="header-anchor">#</a> functional</h3> <p><a href="https://cn.vuejs.org/v2/guide/render-function.html#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6" target="_blank" rel="noopener noreferrer">函数式组件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 这个是文档里就写的内容，但在实际使用者，其实很少人会刻意的去使用，因为你不用它，代码也不会有任何问题，用了到可能会出现 bug。</p> <p><a href="https://vue-9-perf-secrets.netlify.com/bench/functional" target="_blank" rel="noopener noreferrer">点我测试性能<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 肉眼可见的性能差距。当然很多人会觉得我的项目中也没有这种变化量级，但我觉得这是一个程序员的自我修养问题吧。，比如能用<code>v-show</code>的地方就不要用<code>v-if</code>，善用<code>keep-alive</code>和<code>v-once</code>，<code>Object.freeze()</code>处理 <a href="https://github.com/vuejs/vue/issues/4384" target="_blank" rel="noopener noreferrer">vue big data<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 问题等。更多的性能优化技巧请查看该文章<a href="https://slides.com/akryum/vueconfus-2019#/" target="_blank" rel="noopener noreferrer">vue-9-perf-secrets<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="provide-inject"><a href="#provide-inject" aria-hidden="true" class="header-anchor">#</a> provide/inject</h2> <h2 id="sass-和-js-之间变量共享"><a href="#sass-和-js-之间变量共享" aria-hidden="true" class="header-anchor">#</a> sass 和 js 之间变量共享</h2> <p>这个需求可能有些人没有遇到过，举个实际例子来说明一下。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be99f6bc2343c?w=1110&h=566&f=gif&s=864394" alt>
如上面要实现一个动态的换肤，就需要将用户选择的 theme 主题色传递给 css。但同时初始化的时候 css 又需要将一个默认主题色传递给 js。所以下面我们就分两块来讲解。</p> <ul><li><p>js 将变量传递给 sass
这部分是相对简单就可以实现的，实现方案也很多。最简单的方法就是通过 在模板里面写 style 标签来实现，就是俗话所说的内联标签。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">:</span><span class="token style-attr language-css"><span class="token attr-name"><span class="token attr-name">style</span></span><span class="token punctuation">=&quot;</span><span class="token attr-value"><span class="token punctuation">{</span><span class="token string">'background-color'</span><span class="token punctuation">:</span>color<span class="token punctuation">}</span></span><span class="token punctuation">&quot;</span></span> <span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>或者使用 <code>css var()</code>，在线<a href="https://codepen.io/richardtallent/pen/yvpERW/" target="_blank" rel="noopener noreferrer">demo<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，还有用 less 的话<code>modifyVars</code>，等等方案都能实现 js 与 css 的变量传递。</p></li> <li><p>sass 将变量给 js</p></li></ul> <p>还是那前面那个换肤来举例子，我们页面初始化的时候，总需要一个默认主题色吧，假设我们在 <code>var.scss</code>中声明了一个 <code>theme:blue</code>，我们在 js 中该怎么获取这个变量呢？我们可以通过 <a href="https://github.com/css-modules/icss#export" target="_blank" rel="noopener noreferrer">css-modules<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> <code>:export</code>来实现。更具体的解释-<a href="https://www.bluematador.com/blog/how-to-share-variables-between-js-and-sass" target="_blank" rel="noopener noreferrer">How to Share Variables Between Javascript and Sass<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// var.scss</span>
$theme<span class="token punctuation">:</span> blue<span class="token punctuation">;</span>

<span class="token punctuation">:</span><span class="token keyword">export</span> <span class="token punctuation">{</span>
  theme<span class="token punctuation">:</span> $theme<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// test.js</span>
<span class="token keyword">import</span> variables <span class="token keyword">from</span> <span class="token string">'@/styles/var.scss'</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>variables<span class="token punctuation">.</span>theme<span class="token punctuation">)</span> <span class="token comment">// blue</span>
</code></pre></div><p>当 js 和 css 共享一个变量的时候这个方案还是很实用的。vue-element-admin 中的侧边栏的宽度，颜色等等变量都是通过这种方案来实现共享的。</p> <h2 id="自动注册全局组件"><a href="#自动注册全局组件" aria-hidden="true" class="header-anchor">#</a> 自动注册全局组件</h2> <p>我的业务场景大部分是中后台，虽然封装和使用了很多第三方组件，但还是免不了需要封装和使用很多业务组件。但每次用的时候还需要手动引入，真的是很麻烦，浪费了我大量时间。</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be40d5ac05699?w=812&h=466&f=png&s=67387" alt></p> <p>所以我们其实可以基于 webpack 的<code>require.context</code>来实现自动加载组件并注册的全局的功能。相关原理在之前的文章中已经阐述过了。具体代码如下</p> <p><img src="https://user-gold-cdn.xitu.io/2019/3/27/169be4575dc243d9?w=1674&h=402&f=png&s=122245" alt></p> <p>我们可以创建一个<code>GlobalComponents</code>文件夹，将你想要注册到全局的组件都放在这个文件夹里，在<code>index.js</code>里面放上如上代码。之后只要在入口文件<code>main.js</code>中引入即可。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//main.js</span>
<span class="token keyword">import</span> <span class="token string">'./components/Table/index'</span> <span class="token comment">// 自动注册全局业务组件</span>
</code></pre></div><p>这样我们可以在模板中直接使用这些全局组建了。不需要再繁琐的手动引入了。</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>user-select</span><span class="token punctuation">/&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>status-button</span><span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>当然你也不要为了省事，啥组件都往全局注册，这样会让你初始化页面的时候你的初始<code>init bundle</code>很大。你应该就注册那些你经常使用且体积不大的组件，大组件如编辑器或者图表组件还是按需加载比较合理。而且你最好声明这些全局组件的时候有一个统一的命名规范比如：<code>globel-user-select</code>这样的，指定一个团队规范，不然人家看到你这个全局组件会一脸懵逼，这个组件是哪来的。</p> <h3 id="props"><a href="#props" aria-hidden="true" class="header-anchor">#</a> props</h3> <h2 id="lint"><a href="#lint" aria-hidden="true" class="header-anchor">#</a> lint</h2> <p>这又是一个老生常谈的问题了
vue-eslint 一些最佳实践什么的话，这里不讨论了，我觉得看官方的<a href="https://cn.vuejs.org/v2/style-guide/" target="_blank" rel="noopener noreferrer">风格指南<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>差不多就够了。比如避免<code>避免 v-if 和 v-for 用在一起</code>、<code>元素特性的顺序</code>这些等等规则，几十条规则，说真的写了这么就 vue，我也就能记住一些常规的，什么顺序啊，不太可能记住的，这种东西还是交给程序来自动优化才是更合理的选择。</p> <h3 id="roadmap"><a href="#roadmap" aria-hidden="true" class="header-anchor">#</a> RoadMap</h3> <ul><li>更好的多级页面的缓存：目前页面的缓存基于<code>keep-alive</code>，但当三级路由嵌套的情况下，支持的并不好。之后探索一个更好的解决方案。</li> <li>单元测试：当项目大了之后，没有单元测试维护起来还是有些吃力的。
之后会慢慢补上 unit-test 的测试用例。 酌情加上一些<code>e2e-test</code>的例子。</li> <li>去国际化：其实大部分人是不需要国际化的，默认情况下移除国际化。单独开一个国际化分支。</li> <li>适配 webpack5：webpack5 还是解决了不少之前的痛点的，正式版发布之后会进行升级</li> <li>vue 3.0： 等官方发布之后会基于新版本进行重构</li></ul></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/PanJiaChen/awesome-bookmarks/edit/master/docs/blog/other/4.md" target="_blank" rel="noopener noreferrer">在 GitHub 上编辑此页</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">上次更新: </span> <span class="time">4/6/2019, 3:21:30 PM</span></div></div> <!----> </div> <!----></div></div>
    <script src="/awesome-bookmarks/assets/js/app.36e9bca3.js" defer></script><script src="/awesome-bookmarks/assets/js/38.ba319fea.js" defer></script>
  </body>
</html>
